\section{Introduction}
\label{sec:introduction}

Concurrency control is a problem that has always been at the forefront of researchers for some time now. In traditional database systems, the schedulers provide \ac{ACID} properties to transactions that are executed to ensure consistency and correctness. While this is the ideal solution for all transaction scheduling, it's not feasible when transactions are moved to a web service context. The overhead of the locking within web service transactions eliminates the use of traditional scheduling techniques. In order to increase efficiency of many concurrent transactions, the transactional properties of atomicity and isolation are relaxed to prevent the overhead of locking. While this increases efficiency of concurrent transactions, this places the database at a much higher risk of reaching an inconsistent state where data needs to be repaired. The current industry standard is to abandon locking and generate compensating transactions to fix the effects when consistency is lost however, compensating transactions can be very expensive when multiple conflicts occur. In previous work (\cite{ravan_ensuring_2020}) we developed a transaction scheduler that provided a prediction-based analytic to the transaction executing. We used transaction metrics from previous executions to place the transaction in a hierarchical category where we then provided targeted locking. For those transactions that were considered well-behaving, we allow concurrent executions with no locking but those that could potentially cause a cascading rollback, we provided locking to ensure that no other transactions were affected. Going forward in this work we'll simply refer to the prediction-based scheduler as PBS for brevity. 

In this work, we build upon the \ac{PBS} by focusing on the reputation management of the transactions. We use bit-wise scoring based on commit ranking (see Definition \ref{def:commit_ranking}),  efficiency ranking (see Definition \ref{def:efficiency_ranking}), user ranking (see Definition \ref{def:user_ranking}), and system ranking (see Definition \ref{def:system_abort_ranking}) of transactions entering the system. The bit-wise score is then used in a linear fashion to determine locking behaviors for those transactions. Higher scores receive precedence over lower scores therefore allowing for a more granular scheduler that was previously restricted to four categories (see \cite{ravan_ensuring_2020}).

% We focus on identifying classes of transactions (see Definition \ref{transaction_class}) based on the attributes of the transactions and then build a reputation score for those transaction classes. First, we separate the intrinsic (see Definition \ref{intrinsic_attributes}) and extrinsic (see Definition \ref{extrinsic_attributes}) attributes of transactions. The intrinsic attributes are used to identify a particular class of similar transactions. The extrinsic attributes are then used to create a score for the transaction class. 

The scores are calculated after each execution so that the most recent execution's metrics can be taken into consideration. This also prevents adding overhead to the transaction scheduler when transactions enter the system. The score will have already been calculated and a scheduling decision can be made at execution time. The following work details the reputation management system. This chapter is organized in the following order; Section \ref{sec:problem_definition} outlines the problem along with a use-case scenario. Section \ref{sec:related_work} discusses the existing research that has already taken place in regards to the problem. Section \ref{sec:system_model} outlines the system model for the solution. Section \ref{sec:empirical_results} illustrates the simulation results gathered from the prototype.

